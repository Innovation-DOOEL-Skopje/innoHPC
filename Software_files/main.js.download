document.addEventListener('DOMContentLoaded', function () {
   const hamburger = document.querySelector('.hamburger');
   const navLinks = document.querySelector('.nav-links');
   const body = document.body;

   hamburger.addEventListener('click', function () {
      navLinks.classList.toggle('active');
      hamburger.classList.toggle('active');
      // Toggle body class to prevent scrolling
      body.classList.toggle('menu-open');
   });

   // Close mobile menu when clicking a link
   document.querySelectorAll('.nav-links a').forEach((link) => {
      link.addEventListener('click', () => {
         hamburger.classList.remove('active');
         navLinks.classList.remove('active');
         // Remove body class to enable scrolling
         body.classList.remove('menu-open');
      });
   });

   // Hide Navbar on Scroll (disabled: keep navbar always visible)
   let prevScrollPos = window.pageYOffset;
   const navbar = document.querySelector('.navbar');

   window.addEventListener('scroll', () => {
      const currentScrollPos = window.pageYOffset;
      if (navbar) {
         navbar.style.top = '0';
         navbar.style.transform = 'translateY(0)';
      }
      prevScrollPos = currentScrollPos;
   });

   // Updated slider functionality for background images
   let currentSlide = 0;
   const slides = document.querySelectorAll('.slide');
   const dots = document.querySelectorAll('.dot');

   // Set the initial background image and active slide
   function initSlider() {
      slides.forEach((slide) => {
         const imageUrl = slide.getAttribute('data-image');
         slide.style.backgroundImage = `url(${imageUrl})`;
      });

      // Set first slide as active
      slides[0].classList.add('active');
   }

   function showSlide(index) {
      // Remove active class from all slides and dots
      slides.forEach((slide) => slide.classList.remove('active'));
      dots.forEach((dot) => dot.classList.remove('active'));

      // Add active class to current slide and dot
      slides[index].classList.add('active');
      dots[index].classList.add('active');

      currentSlide = index;
   }

   initSlider();

   // Set up dot navigation
   dots.forEach((dot) => {
      dot.addEventListener('click', function () {
         let index = parseInt(this.getAttribute('data-index'));
         showSlide(index);
      });
   });

   // Arrow key navigation for slider
   function nextSlide() {
      currentSlide = (currentSlide + 1) % slides.length;
      showSlide(currentSlide);
   }

   function prevSlide() {
      currentSlide = (currentSlide - 1 + slides.length) % slides.length;
      showSlide(currentSlide);
   }

   // Add keyboard event listener for arrow keys
   document.addEventListener('keydown', function (event) {
      // Only handle arrow keys when slider is visible (user is near top of page)
      if (window.scrollY < window.innerHeight) {
         switch (event.key) {
            case 'ArrowLeft':
               event.preventDefault();
               prevSlide();
               break;
            case 'ArrowRight':
               event.preventDefault();
               nextSlide();
               break;
         }
      }
   });

   // Initialize first slide
   showSlide(0);

   // Navbar scroll effect (keep visible; only toggle scrolled shadow)
   let lastScroll = 0;

   window.addEventListener('scroll', () => {
      const currentScroll = window.pageYOffset;

      if (navbar) {
         navbar.style.transform = 'translateY(0)';
         navbar.style.top = '0';
      }

      // Add/remove scrolled class for shadow only
      if (currentScroll > 50) {
         navbar.classList.add('scrolled');
      } else {
         navbar.classList.remove('scrolled');
      }

      lastScroll = currentScroll;
   });

   // Ensure navbar is visible on resize as well
   window.addEventListener('resize', () => {
      if (navbar) {
         navbar.style.top = '0';
         navbar.style.transform = 'translateY(0)';
      }
   });

   // Text animation color change on scroll
   window.addEventListener('scroll', () => {
      const textElements = document.querySelectorAll('.testimonial-content .quote');
      const viewportHeight = window.innerHeight;
      const scrollPos = window.scrollY;

      textElements.forEach((textElement) => {
         if (!textElement.hasAttribute('data-original')) {
            // Store original text and initialize spans
            textElement.setAttribute('data-original', textElement.innerText);
            const words = textElement.innerText.split(' ');
            textElement.innerHTML = words
               .map((word, index) => `<span data-index="${index}">${word} </span>`)
               .join('');
         }

         // Get element's position relative to viewport
         const rect = textElement.getBoundingClientRect();
         const elementTop = rect.top + scrollPos;
         const elementMiddle = elementTop + rect.height / 2;

         // Progress from 0 to 1 as the element center approaches 70% of viewport
         const threshold = elementMiddle - viewportHeight * 0.7;
         const distance = Math.max(scrollPos - threshold, 0);

         const spans = textElement.querySelectorAll('span');
         const total = spans.length || 1;

         // Map scroll distance to how many words should be painted
         // Increase fill rate for smoother completion (10px per word as baseline)
         const wordsToFill = Math.min(Math.ceil(distance / 10), total);

         spans.forEach((span, index) => {
            const painted = index < wordsToFill;
            span.style.color = painted ? 'rgb(31, 43, 84)' : '#ffffff';
            span.style.textShadow = painted ? 'none' : '2px 2px 4px rgba(0, 0, 0, 0.3)';
            span.style.transition = 'color 0.2s ease, text-shadow 0.2s ease';
         });
      });
   });

   // Store initial positions of text elements
   const initialPositions = new Map();
   const initialStyles = new Map();

   // Hero text scroll animation - Store initial positions
   window.addEventListener('load', () => {
      const slideTexts = document.querySelectorAll(
         '.slide-text-one, .slide-text-two-one,.slide-text-two-two, .slide-text-three'
      );

      slideTexts.forEach((text) => {
         // Store initial position and computed styles
         const rect = text.getBoundingClientRect();
         const computedStyle = window.getComputedStyle(text);

         initialPositions.set(text, {
            top: rect.top + window.pageYOffset,
            left: rect.left,
            transform: computedStyle.transform,
         });

         // Store original styles
         initialStyles.set(text, {
            position: text.style.position,
            top: text.style.top,
            transform: text.style.transform,
         });
      });
   });

   // slider text hide/show on scroll
   window.addEventListener('scroll', () => {
      if (window.innerWidth <= 768) return;

      const slideTexts = document.querySelectorAll(
         '.slide-text-one, .slide-text-two-one,.slide-text-two-two, .slide-text-three'
      );
      const scrollPosition = window.scrollY;
      const viewportHeight = window.innerHeight;

      slideTexts.forEach((text) => {
         const opacity = Math.max(1 - scrollPosition / (viewportHeight * 0.5), 0);
         const clipPathValue = Math.min(scrollPosition / (viewportHeight * 0.3), 1) * 100;

         if (scrollPosition === 0) {
            // Reset to original position and styles
            const originalStyles = initialStyles.get(text);
            Object.assign(text.style, originalStyles);
            text.style.opacity = 1;
            text.style.clipPath = 'none';
         } else {
            const translateY = scrollPosition * 0.3;
            text.style.opacity = opacity;
            text.style.transform = `translateY(${translateY}px)`;
            text.style.clipPath = `polygon(0% 0%, 100% 0%, 100% ${100 - clipPathValue}%, 0% ${
               100 - clipPathValue
            }%)`;
         }

         text.style.transition = 'all 0.3s ease-out';
      });
   });
});

// Replace the blue panel animation with a simpler version
window.addEventListener('DOMContentLoaded', () => {
   // Add console log to verify if script is running
   console.log('Script loaded - checking for panel text');

   const bluePanel = document.querySelector('.blue-panel');
   const panelTextContainer = document.querySelector('.panel-text-container');
   const panelText = document.querySelector('.panel-text');

   if (bluePanel && panelTextContainer && panelText) {
      console.log('Panel elements found:', { bluePanel, panelTextContainer, panelText });
   } else {
      console.error('Panel elements missing:', {
         bluePanel: !!bluePanel,
         panelTextContainer: !!panelTextContainer,
         panelText: !!panelText,
      });
   }
});

// Update the blue panel animation to make centered text disappear differently
window.addEventListener('scroll', () => {
   const bluePanel = document.querySelector('.blue-panel');
   const panelText = document.querySelector('.panel-text');
   const scrollPosition = window.scrollY;
   const viewportHeight = window.innerHeight;

   if (bluePanel && panelText) {
      // Panel scaling animation
      const scaleValue = Math.max(1 - scrollPosition / (viewportHeight * 0.7), 0);
      bluePanel.style.transform = `scaleX(${scaleValue})`;

      // Make text slide downward instead of right
      // This creates a more interesting effect as the user scrolls
      const slideDistance = Math.min(scrollPosition / 2, 200); // Max 200px down

      // Scale down slightly as it slides
      const scaleText = Math.max(1 - scrollPosition / (viewportHeight * 1.2), 0.5);

      // This makes the text slide down as user scrolls
      panelText.style.transform = `translateY(${slideDistance}px) scale(${scaleText})`;

      // Keep opacity full at start but fade out as it slides down
      const opacityValue = Math.max(1 - scrollPosition / (viewportHeight * 0.4), 0);
      panelText.style.opacity = opacityValue;

      if (scrollPosition % 100 === 0) {
         console.log(
            `Scroll: ${scrollPosition}, Panel Scale: ${scaleValue}, Text Y: ${slideDistance}px`
         );
      }
   }
});

window.addEventListener('DOMContentLoaded', function () {
   const lightbox = document.getElementById('lightbox');
   if (!lightbox) return; // Only on news page

   const imgEl = lightbox.querySelector('.lightbox-image');
   const closeBtn = lightbox.querySelector('.lightbox-close');
   const backdrop = lightbox.querySelector('.lightbox-backdrop');

   function openLightbox(src, alt) {
      imgEl.src = src;
      imgEl.alt = alt || 'Certificate preview';
      lightbox.style.display = 'block';
      lightbox.removeAttribute('aria-hidden');
      document.body.style.overflow = 'hidden';
   }

   function closeLightbox() {
      imgEl.src = '';
      lightbox.style.display = 'none';
      lightbox.setAttribute('aria-hidden', 'true');
      document.body.style.overflow = '';
   }

   document.querySelectorAll('.news-card .news-image img').forEach((img) => {
      img.style.cursor = 'zoom-in';
      img.addEventListener('click', () => openLightbox(img.currentSrc || img.src, img.alt));
   });

   if (closeBtn) closeBtn.addEventListener('click', closeLightbox);
   if (backdrop) backdrop.addEventListener('click', closeLightbox);
   document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') closeLightbox();
   });
});
